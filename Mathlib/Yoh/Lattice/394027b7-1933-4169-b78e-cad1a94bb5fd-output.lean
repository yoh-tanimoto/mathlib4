/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 394027b7-1933-4169-b78e-cad1a94bb5fd

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Matrix.specialUnitaryGroup

abbrev SU2 := Matrix.specialUnitaryGroup (Fin 2) ℂ

#check Finset.Ico (0 : ℤ) (5 : ℤ)

/-
Definition of the lattice Omega as a square grid of size L^m x L^m.
-/
def Omega (L m : ℕ) : Finset (ℤ × ℤ) :=
  let N := (L ^ m : ℤ)
  let I := Finset.Ico 0 (N + 1)
  Finset.product I I

#synth Group SU2
#check Matrix.trace
#check Complex.re
#check Star

/-
Definition of the configuration space Conf and the set of oriented bonds OmegaPrime.
-/
def Conf (L m : ℕ) := {x : ℤ × ℤ // x ∈ Omega L m} → SU2

def is_positive_bond (x y : ℤ × ℤ) : Bool :=
  (y.1 == x.1 + 1 && y.2 == x.2) || (y.1 == x.1 && y.2 == x.2 + 1)

def OmegaPrime (L m : ℕ) : Finset ((ℤ × ℤ) × (ℤ × ℤ)) :=
  (Omega L m).product (Omega L m) |>.filter fun x => is_positive_bond x.1 x.2

/-
Definition of the action functional using `Finset.attach` to handle membership proofs.
-/
open scoped BigOperators

def action (L m : ℕ) (U : Conf L m) : ℝ :=
  ∑ b ∈ (OmegaPrime L m).attach,
    let u1 := U ⟨b.1.1, by
      -- Since $b \in \text{OmegaPrime } L m$, we know that $b.1 \in \text{Omega } L m$ by the definition of $\text{OmegaPrime}$.
      apply (Finset.mem_filter.mp b.2).left |> Finset.mem_product.mp |> And.left⟩
    let u2 := U ⟨b.1.2, by
      -- By definition of OmegaPrime, if (x, y) is in OmegaPrime, then y must be in Omega.
      have h_y_in_Omega : ∀ {x y : ℤ × ℤ}, (x, y) ∈ OmegaPrime L m → y ∈ Omega L m := by
        -- By definition of OmegaPrime, if (x, y) is in OmegaPrime, then y must be in Omega because OmegaPrime is a subset of the product of Omega with itself.
        intros x y hxy
        have h_y_in_Omega : y ∈ Omega L m := by
          exact Finset.mem_product.mp ( Finset.mem_filter.mp hxy |>.1 ) |>.2
        exact h_y_in_Omega;
      exact h_y_in_Omega b.2⟩
    Complex.re (Matrix.trace (1 - u1.1 * star u2.1))

/-
Definitions of the coarse lattice Omega1 and the block B(y).
-/
def Omega1 (L m : ℕ) : Finset (ℤ × ℤ) :=
  (Omega L (m - 1)).image (fun x => (L * x.1, L * x.2))

def block (L : ℕ) (y : ℤ × ℤ) : Finset (ℤ × ℤ) :=
  let I := Finset.Ico 0 (L : ℤ)
  Finset.product I I |>.image (fun x => (y.1 + x.1, y.2 + x.2))

/-
Definition of the averaging map mcC_0, handling the domain constraint.
-/
open scoped BigOperators

def mcC_0 (L m : ℕ) (U : Conf L m) (y : ℤ × ℤ) : Matrix (Fin 2) (Fin 2) ℂ :=
  (1 / (L ^ 2 : ℂ)) • ∑ x ∈ block L y,
    if h : x ∈ Omega L m then (U ⟨x, h⟩).1 else 0

/-
Definition of the averaging matrix mcC_matrix (unconstrained).
-/
open scoped BigOperators

noncomputable def mcC_matrix (L m : ℕ) (U : Conf L m) (y : ℤ × ℤ) : Matrix (Fin 2) (Fin 2) ℂ :=
  let M := mcC_0 L m U y
  let d := M.det.re
  if d > 0 then
    (1 / (Real.sqrt d : ℂ)) • M
  else
    1

/-
Definition of the averaging operation mcC, using the auxiliary matrix definition and handling the membership proof conditionally.
-/
open scoped BigOperators

noncomputable def mcC (L m : ℕ) (U : Conf L m) (y : ℤ × ℤ) : SU2 :=
  if h : mcC_matrix L m U y ∈ SU2 then
    ⟨mcC_matrix L m U y, h⟩
  else
    1

/-
Helper lemmas for OmegaPrime membership.
-/
lemma mem_omega_of_mem_omega_prime_left {L m : ℕ} {b : (ℤ × ℤ) × (ℤ × ℤ)} (h : b ∈ OmegaPrime L m) : b.1 ∈ Omega L m := by
  simp [OmegaPrime] at h
  exact h.1.1

lemma mem_omega_of_mem_omega_prime_right {L m : ℕ} {b : (ℤ × ℤ) × (ℤ × ℤ)} (h : b ∈ OmegaPrime L m) : b.2 ∈ Omega L m := by
  simp [OmegaPrime] at h
  exact h.1.2

/-
Definition of the derivative pa U(b) using the subtype for bonds.
-/
open scoped BigOperators

def pa_U (L m : ℕ) (U : Conf L m) (b : { x // x ∈ OmegaPrime L m }) : Matrix (Fin 2) (Fin 2) ℂ :=
  (U ⟨b.1.1, mem_omega_of_mem_omega_prime_left b.2⟩).1 * star (U ⟨b.1.2, mem_omega_of_mem_omega_prime_right b.2⟩).1

#check LinearMap.toContinuousLinearMap

/-
Definition of the operator norm for 2x2 matrices.
-/
open scoped BigOperators

noncomputable def opNorm (A : Matrix (Fin 2) (Fin 2) ℂ) : ℝ :=
  ‖(Matrix.toEuclideanLin A).toContinuousLinearMap‖

/-
Definition of the set of configurations satisfying the small field condition.
-/
open scoped BigOperators

def Conf_eps (L m : ℕ) (eps : ℝ) :=
  { U : Conf L m // ∀ b : { x // x ∈ OmegaPrime L m }, opNorm (pa_U L m U b - 1) ≤ eps }

#check Conf_eps

/-
Definitions for the coarse lattice configuration space and small field condition.
-/
def is_positive_bond_1 (L : ℕ) (x y : ℤ × ℤ) : Bool :=
  (y.1 == x.1 + L && y.2 == x.2) || (y.1 == x.1 && y.2 == x.2 + L)

def OmegaPrime1 (L m : ℕ) : Finset ((ℤ × ℤ) × (ℤ × ℤ)) :=
  (Omega1 L m).product (Omega1 L m) |>.filter fun x => is_positive_bond_1 L x.1 x.2

def Conf1 (L m : ℕ) := {x : ℤ × ℤ // x ∈ Omega1 L m} → SU2

open scoped BigOperators

def pa_V (L m : ℕ) (V : Conf1 L m) (b : { x // x ∈ OmegaPrime1 L m }) : Matrix (Fin 2) (Fin 2) ℂ :=
  (V ⟨b.1.1, by
    -- By definition of OmegaPrime1, if b is in OmegaPrime1 L m, then b.1 must be in Omega1 L m.
    have h_b1_in_Omega1 : ∀ b : { x : (ℤ × ℤ) × ℤ × ℤ // x ∈ OmegaPrime1 L m }, b.val.1 ∈ Omega1 L m := by
      intro b; exact (by
      convert Finset.mem_filter.mp b.2 |>.1 |> Finset.mem_product.mp |>.1);
    exact h_b1_in_Omega1 b⟩).1 * star (V ⟨b.1.2, by
    unfold OmegaPrime1 at b; aesop⟩).1

def Conf1_eps (L m : ℕ) (eps : ℝ) :=
  { V : Conf1 L m // ∀ b : { x // x ∈ OmegaPrime1 L m }, opNorm (pa_V L m V b - (1 : Matrix (Fin 2) (Fin 2) ℂ)) ≤ eps }

/-
Definition of the constraint condition C(U) = V.
-/
def satisfies_constraint (L m : ℕ) (V : Conf1 L m) (U : Conf L m) : Prop :=
  ∀ y : {x // x ∈ Omega1 L m}, mcC L m U y = V y

#check Matrix.IsSkewAdjoint

/-
Definition of the Lie algebra su(2) as trace-zero skew-Hermitian matrices.
-/
def su2 := { A : Matrix (Fin 2) (Fin 2) ℂ // star A = -A ∧ Matrix.trace A = 0 }

#check skewAdjoint

/-
Definition of Pauli matrices.
-/
def sigma1 : Matrix (Fin 2) (Fin 2) ℂ := !![0, 1; 1, 0]
def sigma2 : Matrix (Fin 2) (Fin 2) ℂ := !![0, -Complex.I; Complex.I, 0]
def sigma3 : Matrix (Fin 2) (Fin 2) ℂ := !![1, 0; 0, -1]

def PauliMatrix (i : Fin 3) : Matrix (Fin 2) (Fin 2) ℂ :=
  match i with
  | 0 => sigma1
  | 1 => sigma2
  | 2 => sigma3

/-
Definitions of vector part, sign, and scalar part of SU(2) element.
-/
noncomputable def vec_A (U : SU2) : Fin 3 → ℝ :=
  fun i => match i with
  | 0 => (U.1 0 1).im
  | 1 => (U.1 0 1).re
  | 2 => (U.1 0 0).im

noncomputable def s_A (U : SU2) : ℝ :=
  if (U.1 0 0).re ≥ 0 then 1 else -1

noncomputable def A_0 (U : SU2) : ℝ :=
  Real.sqrt (1 - ‖vec_A U‖^2)

/-
Definition of a linear combination of Pauli matrices.
-/
open scoped BigOperators

noncomputable def PauliVector (v : Fin 3 → ℝ) : Matrix (Fin 2) (Fin 2) ℂ :=
  ∑ i : Fin 3, (v i : ℂ) • PauliMatrix i

/-
Explicit matrix form of PauliVector with correct type casting.
-/
open scoped BigOperators

lemma PauliVector_apply (v : Fin 3 → ℝ) :
  PauliVector v = !![(v 2 : ℂ), (v 0 : ℂ) - Complex.I * (v 1 : ℂ); (v 0 : ℂ) + Complex.I * (v 1 : ℂ), -(v 2 : ℂ)] := by
    -- By definition of Pauli matrices, we can expand the sum.
    have h_expand : PauliVector v = v 0 • sigma1 + v 1 • sigma2 + v 2 • sigma3 := by
      unfold PauliVector; simp +decide [ Fin.sum_univ_three ] ;
      rfl;
    ext i j ; fin_cases i <;> fin_cases j <;> norm_num [ h_expand, sigma1, sigma2, sigma3 ] ; ring!;
    ring

/-
Definition of the rotation matrix R_A.
-/
open scoped Matrix

noncomputable def R_A (U : SU2) (v : Fin 3 → ℝ) : Fin 3 → ℝ :=
  (s_A U * A_0 U) • v + crossProduct (vec_A U) v

/-
Unitarity condition for the first row of an SU(2) matrix.
-/
open scoped Matrix BigOperators

lemma SU2_unitarity (U : SU2) : Complex.normSq (U.1 0 0) + Complex.normSq (U.1 0 1) = 1 := by
  have := U.2.1;
  have := this.2;
  replace := congr_fun ( congr_fun this 0 ) 0; norm_num [ Complex.ext_iff, Matrix.mul_apply ] at * ; aesop;

/-
Definition of the scalar part of an SU(2) element using the Euclidean norm of the vector part.
-/
open scoped Matrix BigOperators

noncomputable def scalar_part (U : SU2) : ℝ :=
  Real.sqrt (1 - (∑ i : Fin 3, (vec_A U i) ^ 2))

/-
Checking the norm instance on Fin 3 -> Real.
-/
#synth Norm (Fin 3 → ℝ)

/-
Identity relating the sum of squares of the vector part to the real part of the top-left entry.
-/
open scoped Matrix BigOperators

lemma one_sub_sum_sq_vec_A_eq_re_sq (U : SU2) : 1 - (∑ i : Fin 3, (vec_A U i) ^ 2) = (U.1 0 0).re ^ 2 := by
  have h_unitarity : Complex.normSq (U.val 0 0) + Complex.normSq (U.val 0 1) = 1 := by
    have := U.2.1
    have := this.2
    replace := congr_fun (congr_fun this 0) 0
    norm_num [Complex.ext_iff, Matrix.mul_apply] at *
    aesop
  unfold vec_A
  rw [Fin.sum_univ_three]
  norm_num [Complex.normSq] at h_unitarity
  linarith

/-
The scalar part is the absolute value of the real part of the top-left entry.
-/
open scoped Matrix BigOperators

lemma scalar_part_eq_abs_re (U : SU2) : scalar_part U = |(U.1 0 0).re| := by
  unfold scalar_part
  rw [one_sub_sum_sq_vec_A_eq_re_sq]
  exact Real.sqrt_sq_eq_abs (U.1 0 0).re

/-
Definition of the tangent space condition for the constraint manifold.
-/
open scoped Matrix BigOperators

def tangent_space_condition (L m : ℕ) (U : Conf L m) (X : {x // x ∈ Omega L m} → Fin 3 → ℝ) : Prop :=
  ∀ y : {x // x ∈ Omega1 L m}, (∑ x ∈ block L y,
    if h : x ∈ Omega L m then R_A (U ⟨x, h⟩) (X ⟨x, h⟩) else 0) = 0

/-
Definition of the linear averaging operator Q.
-/
open scoped BigOperators

def Q (L m : ℕ) (f : {x // x ∈ Omega L m} → Fin 3 → ℝ) (y : {x // x ∈ Omega1 L m}) : Fin 3 → ℝ :=
  (1 / (L ^ 2 : ℝ)) • ∑ x ∈ block L y,
    if h : x ∈ Omega L m then f ⟨x, h⟩ else 0

/-
Definition of the gradient operator pa.
-/
open scoped BigOperators

def pa (L m : ℕ) (f : {x // x ∈ Omega L m} → Fin 3 → ℝ) (b : {x // x ∈ OmegaPrime L m}) : Fin 3 → ℝ :=
  f ⟨b.1.1, mem_omega_of_mem_omega_prime_left b.2⟩ - f ⟨b.1.2, mem_omega_of_mem_omega_prime_right b.2⟩

/-
Definition of the adjoint of the gradient operator pa.
-/
open scoped BigOperators

def pa_adjoint (L m : ℕ) (g : {b // b ∈ OmegaPrime L m} → Fin 3 → ℝ) (x : {x // x ∈ Omega L m}) : Fin 3 → ℝ :=
  ∑ b ∈ (OmegaPrime L m).attach,
    if b.1.2 = x.1 then g b
    else if b.1.1 = x.1 then -(g b)
    else 0

/-
Definition of the Laplacian De_Om.
-/
open scoped BigOperators

def De_Om (L m : ℕ) (f : {x // x ∈ Omega L m} → Fin 3 → ℝ) (x : {x // x ∈ Omega L m}) : Fin 3 → ℝ :=
  - pa_adjoint L m (pa L m f) x

/-
Definition of the block map and proof that it maps Omega to Omega1.
-/
def get_block (L : ℕ) (x : ℤ × ℤ) : ℤ × ℤ :=
  (L * (x.1 / L), L * (x.2 / L))

lemma get_block_mem_omega1 {L m : ℕ} {x : ℤ × ℤ} (h : x ∈ Omega L m) (hL : L > 0) : get_block L x ∈ Omega1 L m := by
  unfold get_block Omega1;
  unfold Omega at *; aesop;
  rcases m <;> aesop;
  · exact ⟨ fst / L, snd / L, ⟨ ⟨ Int.ediv_nonneg left ( by positivity ), Int.ediv_lt_of_lt_mul ( by positivity ) ( by nlinarith ) ⟩, Int.ediv_nonneg left_1 ( by positivity ), Int.ediv_lt_of_lt_mul ( by positivity ) ( by nlinarith ) ⟩, Or.inl rfl, Or.inl rfl ⟩;
  · exact ⟨ fst / L, snd / L, ⟨ ⟨ Int.ediv_nonneg left ( Nat.cast_nonneg _ ), by rw [ Int.ediv_lt_iff_lt_mul ] <;> nlinarith [ pow_succ' ( L : ℤ ) n ] ⟩, Int.ediv_nonneg left_1 ( Nat.cast_nonneg _ ), by rw [ Int.ediv_lt_iff_lt_mul ] <;> nlinarith [ pow_succ' ( L : ℤ ) n ] ⟩, Or.inl rfl, Or.inl rfl ⟩

/-
Definition of the adjoint of the averaging operator Q.
-/
open scoped BigOperators

def Q_adjoint (L m : ℕ) (g : {y // y ∈ Omega1 L m} → Fin 3 → ℝ) (x : {x // x ∈ Omega L m}) : Fin 3 → ℝ :=
  if hL : L > 0 then
    g ⟨get_block L x, get_block_mem_omega1 x.2 hL⟩
  else
    0

/-
Checking if the lemma exists.
-/
#check one_sub_sum_sq_vec_A_eq_re_sq

/-
Definition of the operator H = -Delta + Q*Q.
-/
open scoped BigOperators

noncomputable def H_op (L m : ℕ) (f : {x // x ∈ Omega L m} → Fin 3 → ℝ) (x : {x // x ∈ Omega L m}) : Fin 3 → ℝ :=
  - De_Om L m f x + Q_adjoint L m (Q L m f) x

/-
Definition of the Green function G_Om and the adjoint rotation R_star.
-/
open scoped BigOperators

noncomputable def G_Om (L m : ℕ) (f : {x // x ∈ Omega L m} → Fin 3 → ℝ) : {x // x ∈ Omega L m} → Fin 3 → ℝ :=
  Function.invFun (H_op L m) f

noncomputable def R_star (U : SU2) (v : Fin 3 → ℝ) : Fin 3 → ℝ :=
  (s_A U * A_0 U) • v - crossProduct (vec_A U) v

/-
Definition of the twisted bond variable W and the remainder term r.
-/
open scoped BigOperators

noncomputable def W (L m : ℕ) (U' : Conf L m) (V : Conf1 L m) (b : {x // x ∈ OmegaPrime L m}) : SU2 :=
  if hL : L > 0 then
    let x := b.1.1
    let y := b.1.2
    let y_x := get_block L x
    let y_y := get_block L y
    let V_x := V ⟨y_x, get_block_mem_omega1 (mem_omega_of_mem_omega_prime_left b.2) hL⟩
    let V_y := V ⟨y_y, get_block_mem_omega1 (mem_omega_of_mem_omega_prime_right b.2) hL⟩
    let U'_x := U' ⟨x, mem_omega_of_mem_omega_prime_left b.2⟩
    let U'_y := U' ⟨y, mem_omega_of_mem_omega_prime_right b.2⟩
    U'_x * (V_x * V_y⁻¹) * U'_y⁻¹
  else
    1

noncomputable def r (L m : ℕ) (U' : Conf L m) (V : Conf1 L m) (b : {x // x ∈ OmegaPrime L m}) : Fin 3 → ℝ :=
  vec_A (W L m U' V b) - pa L m (fun x => vec_A (U' x)) b

/-
Definition of vector configurations and squared Euclidean norm.
-/
open scoped Matrix BigOperators

def vConf (L m : ℕ) := {x // x ∈ Omega L m} → Fin 3 → ℝ

def norm_sq (v : Fin 3 → ℝ) : ℝ := ∑ i, v i ^ 2

/-
Lemma stating that the matrix constructed from a vector with norm <= 1 is in SU(2).
-/
open scoped Matrix BigOperators

lemma vec_to_SU2_mem_su2 (v : Fin 3 → ℝ) (h : norm_sq v ≤ 1) :
  let a0 := Real.sqrt (1 - norm_sq v)
  let M : Matrix (Fin 2) (Fin 2) ℂ := (a0 : ℂ) • 1 + Complex.I • PauliVector v
  M ∈ SU2 := by
    constructor <;> norm_num [ PauliVector_apply ];
    · refine' ⟨ _, _ ⟩;
      · ext i j ; fin_cases i <;> fin_cases j <;> norm_num [ Complex.ext_iff, Matrix.mul_apply ];
        · exact ⟨ by rw [ Real.mul_self_sqrt ( sub_nonneg_of_le h ) ] ; unfold norm_sq; norm_num [ Fin.sum_univ_three ] ; ring, by ring ⟩;
        · constructor <;> ring;
        · constructor <;> ring;
        · exact ⟨ by rw [ Real.mul_self_sqrt ( sub_nonneg.mpr h ) ] ; unfold norm_sq; norm_num [ Fin.sum_univ_three ] ; ring, by ring ⟩;
      · ext i j ; fin_cases i <;> fin_cases j <;> norm_num [ Matrix.mul_apply, Complex.ext_iff ] <;> ring;
        · exact ⟨ by rw [ Real.sq_sqrt ( sub_nonneg_of_le h ) ] ; unfold norm_sq; norm_num [ Fin.sum_univ_three ] ; ring, trivial ⟩;
        · norm_num;
        · norm_num;
        · exact ⟨ by rw [ Real.sq_sqrt ( sub_nonneg_of_le h ) ] ; unfold norm_sq; norm_num [ Fin.sum_univ_three ] ; ring, trivial ⟩;
    · norm_num [ Complex.ext_iff, Matrix.det_fin_two ];
      exact ⟨ by rw [ Real.mul_self_sqrt ( sub_nonneg.mpr h ) ] ; unfold norm_sq; norm_num [ Fin.sum_univ_three ] ; ring, by ring ⟩

/-
Definition of the matrix corresponding to a vector in the unit ball.
-/
open scoped Matrix BigOperators

noncomputable def vec_to_matrix (v : Fin 3 → ℝ) (h : norm_sq v ≤ 1) : Matrix (Fin 2) (Fin 2) ℂ :=
  let a0 := Real.sqrt (1 - norm_sq v)
  (a0 : ℂ) • 1 + Complex.I • PauliVector v

/-
Definition of the map from a vector (with norm <= 1) to SU(2).
-/
open scoped Matrix BigOperators

noncomputable def vec_to_SU2 (v : Fin 3 → ℝ) (h : norm_sq v ≤ 1) : SU2 :=
  ⟨vec_to_matrix v h, vec_to_SU2_mem_su2 v h⟩

/-
Square of Pauli vector is norm squared times identity.
-/
open scoped Matrix BigOperators

lemma sq_PauliVector (v : Fin 3 → ℝ) :
  (PauliVector v) ^ 2 = (norm_sq v : ℂ) • (1 : Matrix (Fin 2) (Fin 2) ℂ) := by
    -- Expand PauliVector v as sum.
    have h_expand : PauliVector v = !![(v 2 : ℂ), (v 0 : ℂ) - Complex.I * (v 1 : ℂ); (v 0 : ℂ) + Complex.I * (v 1 : ℂ), -(v 2 : ℂ)] := by
      exact?;
    norm_num [ h_expand, sq ];
    ext i j ; fin_cases i <;> fin_cases j <;> norm_num [ Complex.ext_iff, Matrix.mul_apply, norm_sq ] <;> ring;
    · norm_num [ Fin.sum_univ_three, sq ];
      ring;
    · norm_num;
    · norm_num;
    · norm_cast ; norm_num [ Fin.sum_univ_three ]