import Mathlib
import Mathlib.Yoh.Lattice.Defs

-- Temporary goal: define lattice as a `AddSubgroup` of `(Fin d) → AddCircle L ^ M`,
-- showing that it is isomorphic to `(Fin d) → ZMod L ^ (M + N)`
-- together with `LatticeEmbedding` as `AddGroupHom` which is the identity map
-- first we need to show that the subgroup in `AddCircle (L ^ M)` generated by `L ^ (-N)`
-- is isomorphic to `ZMod L ^ (M + N)`, giving the coordinate.
-- The periodic lattice is will be a subgroup of `ContinuousTorus`, but
-- isomorphic to `ZMod L ^ (M + N)` so that one can take the coordinates.


open Polynomial Filter QuotientAddGroup Submodule MeasureTheory MeasureTheory.Measure
  NNReal BigOperators Function

namespace ZMod

variable (p : ℝ) (P : ℕ) [NeZero P]

/-- The `AddMonoidHom` from `ZMod N` to `ℝ / ℤ` sending `j mod N` to `j / N mod 1`. -/
noncomputable def toScaledAddCircle : ZMod P →+ AddCircle p :=
  ZMod.lift P ⟨AddMonoidHom.mk' (fun j ↦ ↑(p * j / P : ℝ))
  (by simp only [Int.cast_add]; field_simp; ring_nf; simp), by simp⟩

-- adapt APIs for `toAddCircle` to `toScaledAddCircle`

lemma toScaledAddCircle_intCast (j : ℤ) :
    toScaledAddCircle p P (j : ZMod P) = ↑(p * j / P) := by
  field_simp
  simp [toScaledAddCircle]

lemma toScaledAddCircle_natCast (j : ℕ) :
    toScaledAddCircle p P (j : ZMod P) = ↑(p * j / P) := by
  simpa using toScaledAddCircle_intCast p (P := P) j

/--
Explicit formula for `toScaledAddCircle j`. Note that this is "evil" because it uses `ZMod.val`.
Where possible, it is recommended to lift `j` to `ℤ` and use `toScaledAddCircle_intCast` instead.
-/
lemma toScaledAddCircle_apply (j : ZMod P) :
    toScaledAddCircle p P j = ↑(p * j.val / P ) := by
  rw [← toScaledAddCircle_natCast, natCast_zmod_val]

-- variable (P) in
lemma toScaledAddCircle_injective [hp : Fact (0 < p)] :
    Function.Injective (toScaledAddCircle p P : ZMod P → _) := by
  intro x y hxy
  have : (0 : ℝ) < P := Nat.cast_pos.mpr (NeZero.pos _)
  have hx : p * x.val / P ∈ Set.Ico 0 (0 + p) := by
    simp only [zero_add, Set.mem_Ico]
    field_simp
    simp only [zero_mul]
    constructor
    · exact mul_nonneg (le_of_lt hp.out) (Nat.cast_nonneg' x.val)
    · rw [mul_lt_mul_iff_right₀ hp.out, Nat.cast_lt]
      exact val_lt x
  have hy : p * y.val / P ∈ Set.Ico 0 (0 + p) := by
    simp only [zero_add, Set.mem_Ico]
    field_simp
    simp only [zero_mul]
    constructor
    · exact mul_nonneg (le_of_lt hp.out) (Nat.cast_nonneg' y.val)
    · rw [mul_lt_mul_iff_right₀ hp.out, Nat.cast_lt]
      exact val_lt y
  rwa [toScaledAddCircle_apply, toScaledAddCircle_apply, AddCircle.coe_eq_coe_iff_of_mem_Ico hx hy,
    div_left_inj' this.ne', mul_left_cancel_iff_of_pos, Nat.cast_inj,
    (val_injective P).eq_iff] at hxy
  exact hp.out

@[simp] lemma toScaledAddCircle_inj [hp : Fact (0 < p)] {j k : ZMod P} :
    toScaledAddCircle p P j = toScaledAddCircle p P k ↔ j = k :=
  (toScaledAddCircle_injective p P).eq_iff

@[simp] lemma toScaledAddCircle_eq_zero [hp : Fact (0 < p)] {j : ZMod P} :
    toScaledAddCircle p P j = 0 ↔ j = 0 :=
  map_eq_zero_iff _ (toScaledAddCircle_injective p P)

end ZMod

noncomputable section PeriodicLattice

open ZMod

variable (p : ℝ) (P : ℕ) [NeZero P]

def ScaledPeriodicLattice1d : AddSubgroup (AddCircle p) :=
  AddSubgroup.map (toScaledAddCircle p P) ⊤

def ScaledInfiniteLattice1d :=
  AddSubgroup.map ((LinearMap.lsmul ℝ ℝ p : ℝ →+ ℝ).comp (Int.castAddHom ℝ)) (⊤ : AddSubgroup ℤ)

@[simp]
lemma AddCircle.equivAddCircle_apply (p q : ℝ) (hp : 0 < p) (hq : 0 < q) (x : AddCircle p) :
    letI : Fact (0 < p) := { out := hp }
    (equivAddCircle p q (ne_of_gt hp) (ne_of_gt hq)) x
    = (p⁻¹ * q * (AddCircle.equivIco p 0 x).val) := by
  sorry


def AddCircle.equivScaledPeriodicLattice1d (p : ℝ) (hp : 0 < p) (P : ℕ) [NeZero P] (q : ℝ)
    (hq : 0 < q) (Q : ℕ) [NeZero Q] :
    ScaledPeriodicLattice1d p P ≃+ ScaledPeriodicLattice1d q Q where
  toFun x := ⟨(AddCircle.equivAddCircle p q (ne_of_gt hp) (ne_of_gt hq)) x, by sorry⟩
  invFun x := ⟨(AddCircle.equivAddCircle q p (ne_of_gt hq) (ne_of_gt hp)) x, by sorry⟩
  map_add' := by simp
  left_inv := by
    intro x
    simp
    sorry
  right_inv := by sorry

end PeriodicLattice

section QuotientGroupPi

variable {ι : Type*} {G : ι → Type*} [∀ i, Group (G i)] {NG : (i : ι) → Subgroup (G i)}
  [nnormal : ∀ i, (NG i).Normal]

-- #synth (Subgroup.pi Set.univ NG).Normal -- fails

@[to_additive]
instance Subgroup_normal : (Subgroup.pi Set.univ NG).Normal :=
  { conj_mem := fun n hn g i hi => Subgroup.Normal.conj_mem (nnormal i) (n i) (hn i hi) (g i) }

#synth (Subgroup.pi Set.univ NG).Normal

-- missing Pi.mulEquiv? cf. Pi.monoidHom
-- missing the canonical iso between the groups below

#synth Group ((i : ι) → (G i) ⧸ (NG i))
#synth Group (((i : ι) → (G i)) ⧸ (Subgroup.pi Set.univ NG))


end QuotientGroupPi

section QuotientAddGroupPi

variable {ι : Type*} {G : ι → Type*} [∀ i, AddCommGroup (G i)] {NG : (i : ι) → AddSubgroup (G i)}

#synth (AddSubgroup.pi Set.univ NG).Normal

end QuotientAddGroupPi
