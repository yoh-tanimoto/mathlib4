/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ddb4d558-7106-4a48-8b3b-8e3ece474d04
-/

/-
Formalization of short range localizing functions and Lemma 1.2 from the provided LaTeX snippet.

We define the structure `IsShortRangeLocalizing` capturing the properties (i)-(v) of short range localizing functions.
We then state and prove `lemma_1_2`, which asserts a scaling property for the function `b` associated with a short range localizing function `a`.
The proof relies on the decay property of `b` and the finiteness of integer points in bounded balls.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking definitions of EuclideanSpace and PiLp.
-/
#check EuclideanSpace
#check PiLp

/-
Definitions of short range localizing functions and related concepts.
-/
open Real

abbrev Rd (d : ℕ) := EuclideanSpace ℝ (Fin d)
abbrev Zd (d : ℕ) := Fin d → ℤ

def toRd (d : ℕ) (z : Zd d) : Rd d :=
  (EuclideanSpace.equiv (Fin d) ℝ).symm (fun i => (z i : ℝ))

instance (d : ℕ) : Coe (Zd d) (Rd d) where
  coe := toRd d

def b_func (d : ℕ) (δ : ℝ) (a : Rd d → ℝ) (x : Rd d) : ℝ :=
  (1 + ‖x‖) ^ ((d : ℝ) + δ) * a x

def discreteConvolution (d : ℕ) (f g : Rd d → ℝ) (x : Rd d) : ℝ :=
  ∑' y : Zd d, f (x - (y : Rd d)) * g (y : Rd d)

def iteratedConvolution (d : ℕ) (f : Rd d → ℝ) : ℕ → Rd d → ℝ
| 0 => fun _ => 0
| 1 => f
| (n + 1) => discreteConvolution d f (iteratedConvolution d f n)

structure IsShortRangeLocalizing (d : ℕ) (δ : ℝ) (a : Rd d → ℝ) : Prop where
  pos : ∀ x, 0 < a x
  decay : ∃ c_δ ≥ 0, ∀ x, a x ≤ c_δ * (1 + ‖x‖) ^ (-2 * ((d : ℝ) + δ))
  regularity : ∃ K, ∀ x, ∀ y : Rd d, ‖y‖ ≤ 2 * Real.sqrt (d : ℝ) →
    b_func d δ a (x + y) / b_func d δ a x ≤ K
  convolution_bound : ∃ c, ∃ ε > 0, ∀ n ≥ 1, ∀ x,
    iteratedConvolution d (b_func d δ a) n x ≤ c ^ n * b_func d δ a (ε • x)
  eventually_decreasing : ∃ M₀, ∀ x x', M₀ ≤ ‖x‖ → ‖x‖ ≤ ‖x'‖ →
    b_func d δ a x' ≤ b_func d δ a x

/-
The function b(x) tends to 0 as |x| tends to infinity.
-/
theorem lemma_b_tendsto_zero (d : ℕ) (δ : ℝ) (a : Rd d → ℝ) (h : IsShortRangeLocalizing d δ a) (hδ : 0 < δ) :
    Filter.Tendsto (b_func d δ a) (Filter.cocompact (Rd d)) (nhds 0) :=
by
  -- From property (ii), a(x) ≤ c_δ * (1 + |x|)^(-2(d+δ)).
  obtain ⟨c_δ, hc_δ⟩ : ∃ c_δ ≥ 0, ∀ x, a x ≤ c_δ * (1 + ‖x‖) ^ (-2 * ((d : ℝ) + δ)) := by
    exact h.decay;
  -- Using the inequality from property (ii), we can bound the expression.
  have h_bound : ∀ x, (1 + ‖x‖) ^ ((d : ℝ) + δ) * a x ≤ c_δ * (1 + ‖x‖) ^ (-((d : ℝ) + δ)) := by
    intro x; convert mul_le_mul_of_nonneg_left ( hc_δ.2 x ) ( Real.rpow_nonneg ( by positivity : 0 ≤ 1 + ‖x‖ ) ( ( d : ℝ ) + δ ) ) using 1 ; ring;
    rw [ mul_assoc, ← Real.rpow_add ( by positivity ) ] ; ring;
  -- Since $(1 + ‖x‖)^{-((d : ℝ) + δ)}$ tends to $0$ as $‖x‖$ tends to infinity, the product also tends to $0$.
  have h_lim_zero : Filter.Tendsto (fun x : Rd d => (1 + ‖x‖) ^ (-((d : ℝ) + δ))) (Filter.cocompact (Rd d)) (nhds 0) := by
    simpa using tendsto_rpow_neg_atTop ( by positivity : 0 < ( d : ℝ ) + δ ) |> Filter.Tendsto.comp <| tendsto_const_nhds.add_atTop <| tendsto_norm_cocompact_atTop;
  exact squeeze_zero ( fun x => mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( h.pos x |> le_of_lt ) ) h_bound ( by simpa using h_lim_zero.const_mul c_δ )

/-
The set of integer points in Z^d with Euclidean norm bounded by R is finite.
-/
theorem lemma_finite_ball_Zd (d : ℕ) (R : ℝ) : {x : Zd d | ‖(x : Rd d)‖ ≤ R}.Finite := by
  -- Each coordinate i of x is bounded by R, so x i is in the finite set of integers in [-R, R].
  have h_bounded : ∀ x : Zd d, ‖toRd d x‖ ≤ R → ∀ i : Fin d, abs (x i) ≤ R := by
    intro x hx i; specialize hx; have := hx; simp_all +decide [ EuclideanSpace.norm_eq ];
    exact le_trans ( Real.abs_le_sqrt <| Finset.single_le_sum ( fun i _ => sq_nonneg <| toRd d x i ) <| Finset.mem_univ i ) hx;
  -- Therefore, for each coordinate i, x i is bounded by ⌊R⌋, so there are only finitely many possible values for x.
  have h_finite_bound : ∀ x : Zd d, ‖toRd d x‖ ≤ R → ∀ i : Fin d, abs (x i) ≤ ⌈R⌉₊ := by
    exact fun x hx i => by exact_mod_cast le_trans ( h_bounded x hx i ) ( Nat.le_ceil _ ) ;
  exact Set.Finite.subset ( Set.finite_Icc _ _ ) fun x hx => ⟨ fun i => neg_le_of_abs_le <| h_finite_bound x hx i, fun i => le_of_abs_le <| h_finite_bound x hx i ⟩

/-
Lemma 1.2: Let b be as in Definition 1.1. Then, there is 0 < M such that, for all M_tilde in N with M < M_tilde we have b(M_tilde x / 3) <= b(x), x in Z^d.
-/
theorem lemma_1_2 (d : ℕ) (δ : ℝ) (a : Rd d → ℝ) (h : IsShortRangeLocalizing d δ a) (hδ : 0 < δ) :
  ∃ M > 0, ∀ M_tilde : ℕ, M < M_tilde →
    ∀ x : Zd d, b_func d δ a (((M_tilde : ℝ) / 3) • (x : Rd d)) ≤ b_func d δ a x :=
by
  -- By property (v) of IsShortRangeLocalizing, there is an M0 such that b is decreasing for ‖x‖ ≥ M0.
  obtain ⟨M0, hM0⟩ : ∃ M0 ≥ 0, ∀ x x', M0 ≤ ‖x‖ → ‖x‖ ≤ ‖x'‖ → b_func d δ a x' ≤ b_func d δ a x := by
    cases' h.eventually_decreasing with M₀ hM₀;
    exact ⟨ Max.max M₀ 0, le_max_right _ _, fun x x' hx hx' => hM₀ x x' ( le_trans ( le_max_left _ _ ) hx ) hx' ⟩;
  -- For |x| >= 3M0, we have |(M_tilde/3)x| = (M_tilde/3)|x| >= (M/3)|x| >= |x| if M >= 3.
  obtain ⟨M1, hM1⟩ : ∃ M1 ≥ 3, ∀ M_tilde : ℕ, M1 ≤ M_tilde → ∀ x : Zd d, ‖(toRd d x)‖ ≥ 3 * M0 → b_func d δ a ((M_tilde / 3 : ℝ) • toRd d x) ≤ b_func d δ a (toRd d x) := by
    refine' ⟨ 3, by norm_num, fun M_tilde hM_tilde x hx => hM0.2 _ _ _ _ ⟩;
    · linarith;
    · rw [ norm_smul, Real.norm_of_nonneg ( by positivity ) ] ; nlinarith [ show ( M_tilde : ℝ ) ≥ 3 by norm_cast ];
  -- For x in S with x != 0, b(x) > 0 by property (i).
  obtain ⟨M2, hM2⟩ : ∃ M2 ≥ M1, ∀ x : Zd d, ‖(toRd d x)‖ ≤ 3 * M0 → x ≠ 0 → ∀ M_tilde : ℕ, M2 ≤ M_tilde → b_func d δ a ((M_tilde / 3 : ℝ) • toRd d x) ≤ b_func d δ a (toRd d x) := by
    -- For x in S with x != 0, b(x) > 0 by property (i). Since b(y) -> 0 as |y| -> infinity (lemma_b_tendsto_zero), for each x in S, there exists Mx such that for all M_tilde > Mx, b((M_tilde/3)x) <= b(x).
    have hMx : ∀ x : Zd d, ‖(toRd d x)‖ ≤ 3 * M0 → x ≠ 0 → ∃ Mx : ℕ, ∀ M_tilde : ℕ, Mx ≤ M_tilde → b_func d δ a ((M_tilde / 3 : ℝ) • toRd d x) ≤ b_func d δ a (toRd d x) := by
      intros x hx hx_ne_zero
      have h_lim : Filter.Tendsto (fun M_tilde : ℕ => b_func d δ a ((M_tilde / 3 : ℝ) • toRd d x)) Filter.atTop (nhds 0) := by
        have h_lim : Filter.Tendsto (fun y : Rd d => b_func d δ a y) (Filter.cocompact (Rd d)) (nhds 0) := by
          exact?;
        refine' h_lim.comp _;
        have h_lim : Filter.Tendsto (fun M_tilde : ℕ => ‖((M_tilde / 3 : ℝ) • toRd d x)‖) Filter.atTop Filter.atTop := by
          norm_num [ norm_smul ];
          exact Filter.Tendsto.atTop_mul_const ( norm_pos_iff.mpr <| show toRd d x ≠ 0 from fun h => hx_ne_zero <| by ext i; simpa [ toRd ] using congr_fun h i ) <| tendsto_natCast_atTop_atTop.atTop_div_const zero_lt_three;
        norm_num +zetaDelta at *;
        convert h_lim using 1;
        exact?;
      have := h_lim.eventually ( ge_mem_nhds <| show 0 < b_func d δ a ( toRd d x ) from mul_pos ( Real.rpow_pos_of_pos ( add_pos_of_pos_of_nonneg zero_lt_one <| norm_nonneg _ ) _ ) <| h.pos _ ) ; aesop;
    choose! Mx hMx using hMx;
    have := lemma_finite_ball_Zd d ( 3 * M0 );
    exact ⟨ Max.max M1 ( Finset.sup ( this.toFinset ) Mx ), le_max_left _ _, fun x hx hx' M_tilde hM_tilde => hMx x hx hx' M_tilde ( le_trans ( Finset.le_sup ( f := Mx ) ( this.mem_toFinset.mpr hx ) ) ( le_trans ( le_max_right _ _ ) hM_tilde ) ) ⟩;
  use M2 + 1;
  bound;
  by_cases hx : x = 0 <;> simp_all +decide;
  · unfold b_func; norm_num [ toRd ] ;
    erw [ WithLp.toLp_zero ] ; norm_num;
  · by_cases hx' : ‖toRd d x‖ ≤ 3 * M0;
    · exact right_2 x hx' hx M_tilde ( by linarith );
    · exact right_1 M_tilde ( by linarith ) x ( by linarith )

#print axioms lemma_1_2
