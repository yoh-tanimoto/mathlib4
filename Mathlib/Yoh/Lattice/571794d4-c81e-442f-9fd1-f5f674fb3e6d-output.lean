/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 571794d4-c81e-442f-9fd1-f5f674fb3e6d

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check EuclideanSpace

#print WithLp

#check tsum

#check WithLp.equiv
#check PiLp
#check Real.sqrt

/-
Definition 1.1: Short range localizing function.
A function a : ℝ^d → ℝ is short range localizing if:
(i) 0 < a(x)
(ii) a(x) ≤ c_δ (1+|x|)^{-2(d+δ)}
(iii) b(x) := (1+|x|)^{d+δ} a(x) satisfies b(x+y)/b(x) ≤ K for |y| ≤ 2√d
(iv) (b*...*b)(x) ≤ c^n b(ε x)
(v) b is eventually decreasing.
-/
open Real

noncomputable def toEuc {d : ℕ} (f : Fin d → ℝ) : EuclideanSpace ℝ (Fin d) :=
  (WithLp.equiv 2 (Fin d → ℝ)).symm f

noncomputable def discreteConvolution {d : ℕ} (f g : EuclideanSpace ℝ (Fin d) → ℝ) (x : EuclideanSpace ℝ (Fin d)) : ℝ :=
  ∑' (k : Fin d → ℤ), f (x - toEuc (fun i => (k i : ℝ))) * g (toEuc (fun i => (k i : ℝ)))

noncomputable def iteratedConvolution {d : ℕ} (b : EuclideanSpace ℝ (Fin d) → ℝ) (n : ℕ) (x : EuclideanSpace ℝ (Fin d)) : ℝ :=
  match n with
  | 0 => 0
  | 1 => b x
  | (n + 1) => discreteConvolution b (iteratedConvolution b n) x

def ShortRangeLocalizing {d : ℕ} (a : EuclideanSpace ℝ (Fin d) → ℝ) : Prop :=
  (∀ x, 0 < a x) ∧
  (∃ δ > 0, ∃ c_δ ≥ 0,
    (∀ x, a x ≤ c_δ * (1 + ‖x‖) ^ (-2 * (d + δ : ℝ))) ∧
    let b := fun x => (1 + ‖x‖) ^ (d + δ : ℝ) * a x
    (∃ K, ∀ x, ∀ y, ‖y‖ ≤ 2 * Real.sqrt (d : ℝ) → b (x + y) / b x ≤ K) ∧
    (∃ c, ∃ ε > 0, ∀ n, 1 ≤ n → ∀ x, iteratedConvolution b n x ≤ c ^ n * b (ε • x)) ∧
    (∃ M_0, ∀ x x', M_0 ≤ ‖x‖ → ‖x‖ ≤ ‖x'‖ → b x' ≤ b x))

noncomputable def b_aux {d : ℕ} (a : EuclideanSpace ℝ (Fin d) → ℝ) (δ : ℝ) (x : EuclideanSpace ℝ (Fin d)) : ℝ :=
  (1 + ‖x‖) ^ (d + δ : ℝ) * a x

noncomputable def k_to_vec {d : ℕ} (k : Fin d → ℤ) : EuclideanSpace ℝ (Fin d) :=
  toEuc (fun i => (k i : ℝ))

/-
Lemma: b(x) tends to 0 as |x| → ∞.
-/
lemma b_decay {d : ℕ} (a : EuclideanSpace ℝ (Fin d) → ℝ) (δ : ℝ) (c_δ : ℝ)
  (hδ : 0 < δ)
  (ha_pos : ∀ x, 0 ≤ a x)
  (h_decay : ∀ x, a x ≤ c_δ * (1 + ‖x‖) ^ (-2 * (d + δ : ℝ))) :
  Filter.Tendsto (b_aux a δ) (Filter.cocompact (EuclideanSpace ℝ (Fin d))) (nhds 0) := by
    -- We have 0 ≤ b(x) = (1+|x|)^(d+δ) a(x) ≤ c_δ (1+|x|)^{-(d+δ)}. Since d+δ > 0, the RHS tends to 0 as |x| → ∞.
    have h_le : ∀ x, b_aux a δ x ≤ c_δ * (1 + ‖x‖) ^ (-(d + δ : ℝ)) := by
      intro x; convert mul_le_mul_of_nonneg_left ( h_decay x ) ( Real.rpow_nonneg ( show 0 ≤ 1 + ‖x‖ by positivity ) ( d + δ ) ) using 1 ; ring;
      rw [ mul_assoc, ← Real.rpow_add ( by positivity ) ] ; ring;
    refine' squeeze_zero ( fun x => _ ) h_le _;
    · exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( ha_pos x );
    · simpa using tendsto_const_nhds.mul ( tendsto_rpow_neg_atTop ( by linarith : 0 < ( d : ℝ ) + δ ) |> Filter.Tendsto.comp <| tendsto_const_nhds.add_atTop <| tendsto_norm_cocompact_atTop )

/-
Lemma: The set of integer vectors with Euclidean norm bounded by R is finite.
-/
lemma int_ball_finite {d : ℕ} (R : ℝ) : Set.Finite {k : Fin d → ℤ | ‖toEuc (fun i => (k i : ℝ))‖ ≤ R} := by
  -- The set of integer points in a bounded region of Euclidean space is finite. This follows because the region is bounded, so it is contained in some box [-N, N]^d, and the number of integers in [-N, N] is finite. Hence, the set of integer vectors with Euclidean norm bounded by R is finite.
  have h_finite : ∃ N : ℤ, ∀ k : Fin d → ℤ, ‖toEuc (fun i => (k i : ℝ))‖ ≤ R → ∀ i, |k i| ≤ N := by
    -- Since the Euclidean norm is continuous and the set of integer vectors is discrete, the set of integer vectors with norm bounded by R is finite.
    have h_finite : ∃ N : ℝ, ∀ k : Fin d → ℤ, ‖toEuc (fun i => (k i : ℝ))‖ ≤ R → ∀ i, |(k i : ℝ)| ≤ N := by
      use R + 1;
      intro k hk i; specialize hk; rw [ EuclideanSpace.norm_eq ] at hk; aesop;
      exact le_add_of_le_of_nonneg ( le_trans ( Real.abs_le_sqrt <| Finset.single_le_sum ( fun a _ => sq_nonneg <| ( toEuc ( fun i => ( k i : ℝ ) ) ) a ) <| Finset.mem_univ i ) hk ) zero_le_one;
    exact ⟨ ⌈h_finite.choose⌉₊, fun k hk i => by exact_mod_cast le_trans ( h_finite.choose_spec k hk i ) ( Nat.le_ceil _ ) ⟩;
  exact Set.Finite.subset ( Set.finite_Icc _ _ ) fun k hk => ⟨ fun i => neg_le_of_abs_le ( h_finite.choose_spec k hk i ), fun i => le_of_abs_le ( h_finite.choose_spec k hk i ) ⟩

/-
Lemma 1.2: Let b be as in Definition 1.1 above. Then, there is 0 < M such that, for all M̃ ∈ ℕ such that M < M̃, we have b(M̃x / 3) ≤ b(x), x ∈ ℤ^d.
-/
lemma b_scaling {d : ℕ} (a : EuclideanSpace ℝ (Fin d) → ℝ) (δ : ℝ) (c_δ : ℝ) (M_0 : ℝ)
  (hδ : 0 < δ)
  (ha_pos : ∀ x, 0 < a x)
  (h_decay : ∀ x, a x ≤ c_δ * (1 + ‖x‖) ^ (-2 * (d + δ : ℝ)))
  (h_dec : ∀ x x', M_0 ≤ ‖x‖ → ‖x‖ ≤ ‖x'‖ → b_aux a δ x' ≤ b_aux a δ x) :
  ∃ M > 0, ∀ M_tilde : ℕ, M < M_tilde → ∀ k : Fin d → ℤ,
    b_aux a δ (toEuc (fun i => (M_tilde * k i : ℝ) / 3)) ≤ b_aux a δ (toEuc (fun i => (k i : ℝ))) := by
      -- Let S = {k : Z^d | |k| <= 3 * M_0}.
      set S := {k : Fin d → ℤ | ‖toEuc (fun i => (k i : ℝ))‖ ≤ 3 * M_0} with hS_def;
      -- For each non-zero $k \in S$, $b(k) > 0$. Since $b(y) \to 0$, there exists $M_k$ such that for all $M_tilde > M_k$, $b(M_tilde * k / 3) \leq b(k)$.
      have h_Mk : ∀ k ∈ S \ {0}, ∃ M_k : ℕ, ∀ M_tilde : ℕ, M_tilde > M_k → b_aux a δ (toEuc (fun i => (M_tilde : ℝ) * (k i) / 3)) ≤ b_aux a δ (toEuc (fun i => (k i : ℝ))) := by
        -- Since $b(y) \to 0$, there exists $M_k$ such that for all $M_tilde > M_k$, $b(M_tilde * k / 3) \leq b(k)$.
        intros k hk
        have h_lim : Filter.Tendsto (fun M_tilde : ℕ => b_aux a δ (toEuc (fun i => (M_tilde : ℝ) * (k i) / 3))) Filter.atTop (nhds 0) := by
          have h_lim : Filter.Tendsto (fun x : EuclideanSpace ℝ (Fin d) => b_aux a δ x) (Filter.cocompact (EuclideanSpace ℝ (Fin d))) (nhds 0) := by
            apply_rules [ b_decay ];
            exact fun x => le_of_lt ( ha_pos x );
          refine' h_lim.comp _;
          rw [ Filter.tendsto_atTop' ];
          aesop;
          rw [ Filter.mem_cocompact ] at a_1;
          obtain ⟨ t, ht₁, ht₂ ⟩ := a_1;
          -- Since $t$ is compact, there exists $R > 0$ such that $t \subseteq \{ x \in \mathbb{R}^d \mid \|x\| \leq R \}$.
          obtain ⟨ R, hR ⟩ : ∃ R > 0, ∀ x ∈ t, ‖x‖ ≤ R := by
            obtain ⟨ R, hR ⟩ := ht₁.isBounded.exists_pos_norm_le; use Max.max R 1; aesop;
          -- Choose $a$ such that for all $b \geq a$, we have $\|b * k / 3\| > R$.
          obtain ⟨ a, ha ⟩ : ∃ a : ℕ, ∀ b : ℕ, a ≤ b → ‖toEuc (fun i => (b : ℝ) * (k i) / 3)‖ > R := by
            -- Since $k \neq 0$, there exists some $i$ such that $k_i \neq 0$.
            obtain ⟨ i, hi ⟩ : ∃ i : Fin d, k i ≠ 0 := by
              exact Function.ne_iff.mp right;
            -- Since $k_i \neq 0$, we have $\|b * k_i / 3\| = |b * k_i / 3| = |b| * |k_i| / 3$.
            have h_norm : ∀ b : ℕ, ‖toEuc (fun i => (b : ℝ) * (k i) / 3)‖ ≥ |(b : ℝ) * (k i) / 3| := by
              intro b; rw [ EuclideanSpace.norm_eq ] ; aesop;
              exact Real.abs_le_sqrt ( Finset.single_le_sum ( fun i _ => sq_nonneg ( toEuc ( fun i => ( b : ℝ ) * ( k i : ℝ ) / 3 ) i ) ) ( Finset.mem_univ i ) );
            -- Since $|k_i| > 0$, we can choose $a$ such that for all $b \geq a$, we have $|b * k_i / 3| > R$.
            obtain ⟨ a, ha ⟩ : ∃ a : ℕ, ∀ b : ℕ, a ≤ b → |(b : ℝ) * (k i) / 3| > R := by
              norm_num [ abs_div, abs_mul ];
              exact ⟨ ⌊R * 3 / |(k i : ℝ)|⌋₊ + 1, fun n hn => by rw [ lt_div_iff₀ ( by positivity ) ] ; nlinarith [ Nat.lt_of_floor_lt hn, abs_pos.mpr ( show ( k i : ℝ ) ≠ 0 by simpa using hi ), mul_div_cancel₀ ( R * 3 ) ( ne_of_gt ( abs_pos.mpr ( show ( k i : ℝ ) ≠ 0 by simpa using hi ) ) ) ] ⟩;
            exact ⟨ a, fun b hb => lt_of_lt_of_le ( ha b hb ) ( h_norm b ) ⟩;
          exact ⟨ a, fun b hb => ht₂ <| fun h => not_lt_of_ge ( hR.2 _ h ) ( ha b hb ) ⟩;
        exact Filter.eventually_atTop.mp ( h_lim.eventually ( ge_mem_nhds <| show 0 < b_aux a δ ( toEuc fun i => ( k i : ℝ ) ) from mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) <| ha_pos _ ) ) |> fun ⟨ M, hM ⟩ ↦ ⟨ M, fun n hn ↦ hM n hn.le ⟩;
      -- Since S is finite, let M_max be the maximum of M_k for k in S \ {0}.
      obtain ⟨M_max, hM_max⟩ : ∃ M_max : ℕ, ∀ k ∈ S \ {0}, ∃ M_k ≤ M_max, ∀ M_tilde : ℕ, M_tilde > M_k → b_aux a δ (toEuc (fun i => (M_tilde : ℝ) * (k i) / 3)) ≤ b_aux a δ (toEuc (fun i => (k i : ℝ))) := by
        have hS_finite : Set.Finite S := by
          exact?;
        choose! M hM using h_Mk;
        exact ⟨ Finset.sup ( hS_finite.toFinset.filter fun k => k ≠ 0 ) M, fun k hk => ⟨ M k, Finset.le_sup ( f := M ) ( by aesop ), hM k hk ⟩ ⟩;
      refine' ⟨ M_max + 3, by positivity, fun M_tilde hM_tilde k => _ ⟩ ; by_cases hk : k = 0 <;> simp_all +decide [ abs_div ];
      by_cases hkS : k ∈ S <;> simp_all +decide [ abs_div ];
      · obtain ⟨ M_k, hM_k₁, hM_k₂ ⟩ := hM_max k hkS hk ; exact hM_k₂ _ ( by linarith );
      · refine' h_dec _ _ _ _;
        · linarith [ norm_nonneg ( toEuc fun i => ( k i : ℝ ) ) ];
        · -- By definition of norm, we know that ‖toEuc (fun i => (M_tilde : ℝ) * (k i) / 3)‖ = (M_tilde / 3) * ‖toEuc (fun i => (k i : ℝ))‖.
          have h_norm : ‖toEuc (fun i => (M_tilde : ℝ) * (k i) / 3)‖ = (M_tilde / 3) * ‖toEuc (fun i => (k i : ℝ))‖ := by
            convert norm_smul ( M_tilde / 3 : ℝ ) ( toEuc fun i => ( k i : ℝ ) ) using 1 ; ring;
            · congr ; ext ; norm_num ; ring;
              exact?;
            · rw [ Real.norm_of_nonneg ( by positivity ) ];
          nlinarith [ show ( M_tilde : ℝ ) ≥ M_max + 4 by norm_cast, show ( 0 : ℝ ) ≤ ‖toEuc fun i => ( k i : ℝ )‖ by positivity ]

/-
Definitions of Grid, intToEuc, and Box.
Grid d is the set of functions from Fin d to ℤ (integer lattice).
intToEuc converts a grid point to a Euclidean space vector.
Box M j is the set of grid points k such that |k_i - M * j_i| ≤ M for all i.
-/
abbrev Grid (d : ℕ) := Fin d → ℤ

noncomputable def intToEuc {d : ℕ} (k : Grid d) : EuclideanSpace ℝ (Fin d) :=
  toEuc (fun i => (k i : ℝ))

def Box {d : ℕ} (M : ℕ) (j : Grid d) : Set (Grid d) :=
  {k | ∀ i, |k i - (M : ℤ) * j i| ≤ (M : ℤ)}

#check lp
#check Memℓp

/-
Lemma: Box M j is a finite set.
-/
lemma Box_finite {d : ℕ} (M : ℕ) (j : Grid d) : (Box M j).Finite := by
  -- Since the domain Fin d is finite, the product set is finite as well.
  have h_finite : Set.Finite {k : Fin d → ℤ | ∀ i, -M ≤ k i - (M : ℤ) * j i ∧ k i - (M : ℤ) * j i ≤ M} := by
    exact Set.Finite.subset ( Set.finite_Icc _ _ ) fun k hk => ⟨ fun i => show k i ≥ -M + ( M : ℤ ) * j i by linarith [ hk i ], fun i => show k i ≤ M + ( M : ℤ ) * j i by linarith [ hk i ] ⟩;
  exact h_finite.subset fun k hk => fun i => ⟨ by linarith [ abs_le.mp ( hk i ) ], by linarith [ abs_le.mp ( hk i ) ] ⟩

/-
Definition of the function underlying BoxProj.
-/
noncomputable def BoxProjFun {d : ℕ} (M : ℕ) (j : Grid d) (f : lp (fun _ : Grid d => ℝ) 2) : lp (fun _ : Grid d => ℝ) 2 :=
  ∑ k ∈ (Box_finite M j).toFinset, lp.single 2 k (f k)

/-
Definition of BoxProj as a linear map.
-/
noncomputable def BoxProjLin {d : ℕ} (M : ℕ) (j : Grid d) : (lp (fun _ : Grid d => ℝ) 2) →ₗ[ℝ] (lp (fun _ : Grid d => ℝ) 2) :=
  { toFun := BoxProjFun M j
    map_add' := by
      -- To show that BoxProjFun M j is linear, we need to verify that it preserves addition.
      intros x y
      simp [BoxProjFun];
      rw [ Finset.sum_add_distrib ]
    map_smul' := by
      unfold BoxProjFun; aesop }

/-
Lemma: The norm of BoxProjLin f is bounded by the norm of f.
-/
lemma BoxProjLin_bound {d : ℕ} (M : ℕ) (j : Grid d) (f : lp (fun _ : Grid d => ℝ) 2) :
  ‖BoxProjLin M j f‖ ≤ 1 * ‖f‖ := by
    have h_sum_le : ∑' k : Grid d, |(BoxProjFun M j f) k| ^ 2 ≤ ∑' k : Grid d, |f k| ^ 2 := by
      refine' Summable.tsum_le_tsum _ _ _;
      · unfold BoxProjFun; aesop;
        positivity;
      · -- Since $BoxProjFun M j f$ is zero outside of $Box M j$, the sum $\sum_{k \in \mathbb{Z}^d} |(BoxProjFun M j f) k|^2$ is finite.
        have h_sum_finite : Set.Finite {k : Grid d | (BoxProjFun M j f) k ≠ 0} := by
          exact Set.Finite.subset ( Set.Finite.image ( fun k : Grid d => k ) ( Set.Finite.toFinset ( Box_finite M j ) |> Finset.finite_toSet ) ) fun x hx => by unfold BoxProjFun at hx; aesop;
        refine' summable_of_ne_finset_zero _;
        exacts [ h_sum_finite.toFinset, fun k hk => by simpa using hk ];
      · simpa using f.2.summable;
    simp_all +decide [ lp.norm_eq_tsum_rpow ];
    exact Real.rpow_le_rpow ( tsum_nonneg fun _ => sq_nonneg _ ) h_sum_le ( by norm_num )

/-
Definition of BoxProj as a continuous linear map.
-/
noncomputable def BoxProj {d : ℕ} (M : ℕ) (j : Grid d) : (lp (fun _ : Grid d => ℝ) 2) →L[ℝ] (lp (fun _ : Grid d => ℝ) 2) :=
  (BoxProjLin M j).mkContinuous 1 (BoxProjLin_bound M j)

/-
Lemma: BoxProj M j f k equals f k if k is in Box M j, and 0 otherwise.
-/
lemma BoxProj_apply {d : ℕ} (M : ℕ) (j : Grid d) (f : lp (fun _ : Grid d => ℝ) 2) (k : Grid d) :
  BoxProj M j f k = if k ∈ Box M j then f k else 0 := by
    -- By definition of BoxProj, we can expand it as a sum over the finite set Box M j.
    have h_expand : (BoxProj M j f) = ∑ k' ∈ (Box_finite M j).toFinset, lp.single 2 k' (f k') := by
      exact?;
    split_ifs <;> simp_all +decide [ Finset.sum_apply, lp.single_apply ]

#check BoxProj

#check Real.smoothTransition

#check ContDiffOn.analyticOn
#print ContDiffOn.analyticOn
#check ContDiff
#check SmoothBumpFunction

#check deriv
#check ContDiff
#print ContDiff

/-
Definition of GoodBumpFunction and h_j.
GoodBumpFunction h satisfies the properties of the bump function h in the paper.
h_j is the product of h scaled and shifted.
-/
def GoodBumpFunction (h : ℝ → ℝ) : Prop :=
  (ContDiff ℝ (⊤ : ℕ∞) h) ∧
  (∀ x, 0 ≤ h x) ∧
  (∀ x, |x| ≤ 1/3 → h x = 1) ∧
  (∀ x, 2/3 ≤ |x| → h x = 0) ∧
  (∀ x, ∑' j : ℤ, (h (x - j))^2 = 1) ∧
  (∀ x, |deriv h x| ≤ 10)

noncomputable def h_j {d : ℕ} (h : ℝ → ℝ) (M : ℕ) (j : Grid d) (x : Grid d) : ℝ :=
  ∏ i : Fin d, h ((x i : ℝ) / M - j i)

/-
Definition of RawBump(x) = 1 - smoothTransition(3|x| - 1).
-/
noncomputable def RawBump (x : ℝ) : ℝ := 1 - Real.smoothTransition (3 * |x| - 1)

/-
Lemma: RawBump is 1 on [-1/3, 1/3].
-/
lemma RawBump_one (x : ℝ) (h : |x| ≤ 1/3) : RawBump x = 1 := by
  unfold RawBump;
  norm_num [ Real.smoothTransition ];
  exact Or.inl ( by linarith )