import Mathlib
import Mathlib.Yoh.Lattice.Defs

-- Temporary goal: define lattice as a `AddSubgroup` of `(Fin d) → AddCircle L ^ M`,
-- showing that it is isomorphic to `(Fin d) → ZMod L ^ (M + N)`
-- together with `LatticeEmbedding` as `AddGroupHom` which is the identity map
-- first we need to show that the subgroup in `AddCircle (L ^ M)` generated by `L ^ (-N)`
-- is isomorphic to `ZMod L ^ (M + N)`, giving the coordinate.
-- The periodic lattice is will be a subgroup of `ContinuousTorus`, but
-- isomorphic to `ZMod L ^ (M + N)` so that one can take the coordinates.

open Polynomial Filter QuotientAddGroup Submodule MeasureTheory MeasureTheory.Measure
  NNReal BigOperators

class ParameterSet where
  d : ℕ
  L : ℕ
  M : ℕ
  N : ℕ

variable {d' : SpaceDimension} {L' : RGStepL}
  (M' : SideLength) (N' : LatticeSpacing)

export ParameterSet (d L M N)

variable [ps : ParameterSet] {μb gc : ℝ}

#check d

class OneLtL : Prop where
  out : 1 < L

variable [hL : @OneLtL ps]

instance : Fact (0 < (L ^ M : ℝ)) :=
    Fact.mk (by
      rw [← Nat.cast_pow]
      exact Nat.cast_pos'.mpr (pow_pos (lt_trans zero_lt_one hL.out) M))

instance : NeZero L := NeZero.of_gt hL.out

noncomputable section PeriodicLattice

abbrev ContinuousTorus := (Fin d) → (AddCircle (L ^ M : ℝ))

def FineBasisVector (i : Fin d) : ContinuousTorus := (fun j => if i = j then (1 / N : ℝ) else 0)

def ScaledBasisVector (k : Fin N) (i : Fin d) :
    ContinuousTorus := (fun j => if i = j then (k / N : ℝ) else 0)

def FineBasis : Set ContinuousTorus :=
  Set.range (fun (i : Fin d) => FineBasisVector i)

def ScaledBasis (k : Fin N) : Set ContinuousTorus :=
  Set.range (fun (i : Fin d) => ScaledBasisVector k i)

def ScaledInfiniteLattice1d (p : ℝ) :=
  AddSubgroup.map ((LinearMap.lsmul ℝ ℝ p : ℝ →+ ℝ).comp (Int.castAddHom ℝ)) (⊤ : AddSubgroup ℤ)

lemma ScaledInfiniteLattice1d_eq (p : ℝ) :
    ScaledInfiniteLattice1d p = AddSubgroup.zmultiples p := by
  ext x
  rw [ScaledInfiniteLattice1d, AddSubgroup.mem_map, AddSubgroup.mem_zmultiples_iff]
  simp only [AddSubgroup.mem_top, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Int.coe_castAddHom,
    Function.comp_apply, LinearMap.lsmul_apply, smul_eq_mul, true_and, zsmul_eq_mul]
  constructor
  · intro h
    obtain ⟨q, hq⟩ := h
    use q
    rw [← hq]
    exact Int.cast_comm q p
  · intro h
    obtain ⟨q, hq⟩ := h
    use q
    rw [← hq]
    exact Eq.symm (Int.cast_comm q p)

def ScaledPeriodicLattice1d (k : Fin N) :=
  AddSubgroup.map (QuotientAddGroup.mk' (AddSubgroup.zmultiples (L ^ M : ℝ)))
    (ScaledInfiniteLattice1d (1 / (L ^ (N - k) : ℝ)))

variable (k : Fin N)
#check (ScaledPeriodicLattice1d k : AddSubgroup (AddCircle (L ^ M : ℝ)))

lemma ScaledPeriodicLattice1d_eq_Submodule_span (k : Fin N) :
    ScaledPeriodicLattice1d k =
    AddSubgroup.zmultiples
    ((QuotientAddGroup.mk' (AddSubgroup.zmultiples (L ^ M : ℝ))) (1 / (L ^ (N - k) : ℝ))) := by
  ext x
  simp only [one_div, mk'_apply]
  constructor
  · intro h
    obtain ⟨y, hy⟩ := AddSubgroup.mem_map.mp h
    simp only [one_div, mk'_apply] at hy
    rw [ScaledInfiniteLattice1d_eq] at hy
    rw [← hy.right]
    obtain ⟨m, hm⟩ := AddSubgroup.mem_zmultiples_iff.mp hy.left
    rw [AddSubgroup.mem_zmultiples_iff]
    use m
    rw [← hm]
    simp
  · intro h
    obtain ⟨m, hm⟩ := AddSubgroup.mem_zmultiples_iff.mp h
    rw [ScaledPeriodicLattice1d]
    simp only [one_div, AddSubgroup.mem_map, mk'_apply]
    use m • (L ^ (N - k) : ℝ )⁻¹
    refine ⟨?_, hm⟩
    rw [ScaledInfiniteLattice1d_eq]
    simp

def SMulEquiv {p : ℝ} (hp : p ≠ 0) : ℝ ≃+ ℝ where
  toFun x := p • x
  invFun x := p⁻¹ • x
  map_add' := smul_add _
  left_inv := by
    intro x
    simp [smul_eq_mul, ← mul_assoc, inv_mul_cancel₀ hp]
  right_inv := by
    intro x
    simp [smul_eq_mul, ← mul_assoc, mul_inv_cancel₀ hp]

def ZEmbedAddMonoidHom {p : ℝ} (hp : p ≠ 0) : ℤ →+ ℝ where
  toFun := (SMulEquiv hp).comp (Int.castAddHom ℝ).toAddHom
  map_zero' := by simp
  map_add' := by simp

-- want `toZMod : ScaledPeriodicLattice1d k ≃+ ZMod (L ^ (M + N - k))`.
-- note that `ZMod n` is defined as `Fin n`, but
-- so and `ScaledPeriodicLattice1d k` is also defined as a quotient.
-- need first that `ℤ ⧸ n` is isom to its image in `ℝ`.
--· `ℤ` is isom to its image in `ℝ` by `Int.castAddHom ℝ`
def ZinR := (Int.castAddHom ℝ).range
#check ZinR
--· `ZinR` is isom to `1 / L ^ (M + N - k) • ℤ` by `AddSubgroup.map`
--  with respect to the scalar multiplication.
--· We should take `AddSubgroup.map` with respect to
--  `QuotientAddGroup.mk' (AddSubgroup.zmultiples (L ^ M : ℝ))`
--  which is `Subgroup AddCircle (L ^ M : ℝ)`
--· Want the `AddEquiv` from this to `ZMod (L ^ (M + N - k))`,
--  through `Int.quotientZMultiplesEquivZMod : ℤ ⧸ n ≃+ ZMod n`
--· One can use `QuotientAddGroup.equivQuotientZSMulOfEquiv`,
--  from `ZinR ≃+ ScaledInfiniteLattice1d (1 / (L ^ (N - k) : ℝ))`
--  to get
--  `ZinR ⧸ L ^ (M + N - k)`
--  `≃+ ScaledInfiniteLattice1d (1 / (L ^ (N - k) : ℝ)) ⧸ L ^ M`
--· Moreover, we need
--  `ScaledInfiniteLattice1d (1 / (L ^ (N - k) : ℝ)) ⧸ (zsmulAddGroupHom L ^ M).range`
--  `≃+ ScaledPeriodicLattice k`.
--  use `QuotientAddGroup.quotientMapAddSubgroupOfOfLe` to make this last
--  identification (it uses internally `QuotientAddGroup.map` )
--  to obtain `H ⧸ N.addSubgroupOf H →+ (⊤ : Subgroup G) ⧸ N.addSubgroupOf (⊤ : Subgroup G)`
--  use `Subgroup.topEquiv : ↥⊤ ≃* G` and `QuotientAddGroup.map`
--  to get `(⊤ : Subgroup G) ⧸ N.subgroupOf ⊤ ≃* G ⧸ N)`
--  `variable (G : Type) [CommGroup G] (H N : Subgroup G) [N.Normal]`
--  `QuotientGroup.map (N.subgroupOf ⊤) N ⟨⟨Subgroup.topEquiv.toFun, by simp⟩, Subgroup.topEquiv.map_mul'⟩`
--  `(by intro x h; simp; exact Subgroup.mem_subgroupOf.mp h)`

--  or perhaps use `QuotientGroup.map` from the beginning with
-- `G = ℤ`, `N = zsmulAddGroupHom L ^ (M + N - k)`
-- `H = ℝ`, `M = zsmulAddGroupHom (L ^ M : ℝ)`

#check (AddSubgroup.zmultiples (L ^ M : ℝ))

def ZModEmbedding : ℤ ⧸ (AddSubgroup.zmultiples (L ^ (M + N - k) : ℤ)) →+ AddCircle (L ^ M : ℝ) :=
  let hLReal : 1 < (L : ℝ) := by rw [← Nat.cast_one]; exact Nat.cast_lt.mpr hL.out
  let hLkN := (one_div_ne_zero (pow_ne_zero (N - k) (ne_of_gt (lt_trans zero_lt_one hLReal))))
  QuotientAddGroup.map (AddSubgroup.zmultiples (L ^ (M + N - k) : ℤ)) (AddSubgroup.zmultiples (L ^ M : ℝ))
  (ZEmbedAddMonoidHom hLkN)
  (by intro x h
      rw [ZEmbedAddMonoidHom]
      simp
      rw [SMulEquiv]
      simp
      rw [AddSubgroup.mem_zmultiples_iff]
      rw [AddSubgroup.mem_zmultiples_iff] at h
      obtain ⟨n, hn⟩ := h
      use n
      field_simp
      ring
      rw [← hn]
      simp
      ring
      rw [← pow_add]
      congr
      exact?)

-- compose with `Int.quotientZMultiplesEquivZMod`


def ScaledLattice (k : Fin N) := Submodule.span ℤ (ScaledBasis k)

abbrev ScaledLattice' (k : Fin N) := (Fin d) → ScaledPeriodicLattice1d k

section QuotientGroupPi

variable {ι : Type*} {G : ι → Type*} [∀ i, Group (G i)] {NG : (i : ι) → Subgroup (G i)}
  [nnormal : ∀ i, (NG i).Normal]

-- #synth (Subgroup.pi Set.univ NG).Normal -- fails

@[to_additive]
instance Subgroup_normal : (Subgroup.pi Set.univ NG).Normal :=
  { conj_mem := fun n hn g i hi => Subgroup.Normal.conj_mem (nnormal i) (n i) (hn i hi) (g i) }

#synth (Subgroup.pi Set.univ NG).Normal

-- missing Pi.mulEquiv? cf. Pi.monoidHom
-- missing the canonical iso between the groups below

#synth Group ((i : ι) → (G i) ⧸ (NG i))
#synth Group (((i : ι) → (G i)) ⧸ (Subgroup.pi Set.univ NG))


end QuotientGroupPi

section QuotientAddGroupPi

variable {ι : Type*} {G : ι → Type*} [∀ i, AddCommGroup (G i)] {NG : (i : ι) → AddSubgroup (G i)}

#synth (AddSubgroup.pi Set.univ NG).Normal

end QuotientAddGroupPi


def ScaledLattice.component (k : Fin N) (x : ScaledLattice k) (j : Fin d) :
    Set.Ioc (0 : ℝ) (0 + L ^ M) :=
  AddCircle.equivIoc (L ^ M : ℝ) 0 (x.val j)

lemma mem_ScaledLattice_iff (k : Fin N) (x : ContinuousTorus) : x ∈ ScaledLattice k ↔
    ∀ j, ∃ (m : ℕ), AddCircle.equivIoc (L ^ M : ℝ) 0 (x j) = (m / L ^ N : ℝ) := by
  constructor
  · intro h j
    sorry
  · sorry

def FineLattice := AddSubgroup.closure FineBasis

lemma ScaledBasisVector_in_ScaledLattice {k : Fin N} {i : Fin d} :
    ScaledBasisVector k i ∈ ScaledLattice k := Submodule.mem_span_of_mem (Set.mem_range_self _)

lemma FineBasisVector_in_FineLattice {i : Fin d} : FineBasisVector i ∈ FineLattice :=
  AddSubgroup.mem_closure_of_mem (Set.mem_range_self _)

abbrev FineLattice' {L' : RGStepL} (M' : SideLength) (N' : LatticeSpacing) :=
  (Fin d') → Fin (L' ^ (M' + N'))

variable (x : FineLattice) (j : Fin d)

noncomputable def shiftOne {k : Fin N} (i : Fin d) : ScaledLattice k → ScaledLattice k :=
  fun x => x + ⟨(ScaledBasisVector k i), ScaledBasisVector_in_ScaledLattice⟩

noncomputable def shiftOne' (n : Fin d') : @FineLattice' d' L' M' N' → @FineLattice' d' L' M' N' :=
  fun x => fun m => if m = n then x m else x m + 1

end PeriodicLattice

noncomputable section LatticeField

abbrev ScaledLatticeField (k : Fin N) := ScaledLattice k → ℝ

abbrev LatticeField := FineLattice → ℝ

abbrev LatticeField' {M' : SideLength} {N' : LatticeSpacing} := @FineLattice' d' L' M' N' → ℝ

variable (ϕ : LatticeField) (x : FineLattice)

def scaledFieldNorm {k : Fin N} (ϕ : ScaledLatticeField k) : ℝ :=
  (∫ (x : ScaledLattice k), (ϕ x) ^ 2 ∂count) / L ^ (d * (N - k))

def fieldNorm (ϕ : LatticeField) : ℝ :=
  (∫ (x : FineLattice), (ϕ x) ^ 2 ∂count) / L ^ (d * N)

def fieldNorm' {M' : SideLength} {N' : LatticeSpacing} (ϕ : @LatticeField' d' L' M' N') : ℝ :=
  (∫ (x : @FineLattice' d' L' M' N'), (ϕ x) ^ 2 ∂count) / L' ^ (d' * N')

def partialDeriv {k : Fin N} (i : Fin d) :
    ScaledLatticeField k → ScaledLatticeField k :=
  fun ϕ => fun x => (ϕ (shiftOne i x) - ϕ x) / L ^ (N - k)

def partialDeriv' {M' : SideLength} {N' : LatticeSpacing} (n : Fin d') :
    @LatticeField' d' L' M' N' → @LatticeField' d' L' M' N' :=
  fun ϕ => fun x => (ϕ (shiftOne' M' N' n x) - ϕ x) / L' ^ N'

def LatticeEmbedding {k₁ k₂ : Fin N} (h : k₁ < k₂) :
    ScaledLattice k₂ → ScaledLattice k₁ :=
  fun x => ⟨fun (j : Fin d) => ((x : ContinuousTorus) j : AddCircle (L ^ M : ℝ)), by sorry⟩
-- need to show that `x` in a finer lattice is in the ℤ-span of coarser lattice basis.
-- maybe I should construct API to take components
-- look around Mathlib.Analysis.Fourier.ZMod, Mathlib.Topology.Instances.AddCircle.Real
-- and develop APIs
-- make an isomorphism between this and Mathlib.Data.ZMod.Basic

def LatticeEmbedding' {M' : SideLength} {N₁ N₂ : LatticeSpacing} (h : N₁ < N₂) :
    @FineLattice' d' L' M' N₁ → @FineLattice' d' L' M' N₂ :=
  fun x => fun n => Fin.ofNat (L' ^ (M' + N₂)) (x n * (L' ^ (N₂ - N₁)))

end LatticeField

section Weight

abbrev FieldWeight' {M' : SideLength} {N' : LatticeSpacing} := @LatticeField' d' L' M' N'  → ℝ≥0

noncomputable def blockAveraging' {M' : SideLength} {N' : LatticeSpacing} :
    @LatticeField' d' L' M' (N' + 1) → @LatticeField' d' L' M' N' :=
  fun ϕ => fun x =>
    ∑ x' ∈ {s : @FineLattice' d' L' M' (N' + 1) | ∀ n, s n < L'},
      ϕ (fun n => (LatticeEmbedding' (lt_add_one N') x n) + x' n
        - (Fin.ofNat (L' ^ (M' + (N' + 1))) (L' / 2 : ℕ))) / L' ^ d'

lemma pow_sub_one_le' : L' ^ (M' + N') ≤ L' ^ (M' + (N' + 1)) := by
  apply Nat.pow_le_pow_of_le hL.out
  simp

noncomputable def blockConstant' {M' : SideLength} {N' : LatticeSpacing} :
    @LatticeField' d' L' M' N' → @LatticeField' d' L' M' (N' + 1) :=
  fun ϕ => fun x => ϕ (fun n => (Fin.ofNat (L' ^ (M' + N')) (((x n : ℕ)+ L' / (2 : ℕ)) / L')))

@[simp]
lemma blockConstant_apply' {M' : SideLength} {N' : LatticeSpacing} (ϕ : @LatticeField' d' L' M' N')
    (x : @FineLattice' d' L' M' (N' + 1)) :
    blockConstant' ϕ x = ϕ (fun n => Fin.ofNat (L' ^ (M' + N')) (((x n : ℕ)+ L' / (2 : ℕ)) / L')) := by
  rfl

lemma blockAC_eq_id' {M' : SideLength} {N' : LatticeSpacing} :
    @blockAveraging' d' L' _ M' N' ∘ @blockConstant' d' L' _ M' N' = id := by
  ext ϕ x
  simp only [Function.comp_apply, id_eq]
  sorry

end Weight


section FreeFlow

noncomputable def HFree' {M' : SideLength} {N' : LatticeSpacing} (ϕ : @LatticeField' d' L' M' N')
  {μb : ℝ} : ℝ :=
  Real.exp (- ((∑ n, fieldNorm' (partialDeriv' n ϕ)) + μb * fieldNorm' ϕ) / 2)

noncomputable def freePartitionFunction' : ℝ :=
  ∫ (ϕ : @LatticeField' d' L' M' N'), Real.exp (@HFree' d' L' _ M' N' ϕ μb) ∂count

-- multivariate Gaussian Mathlib.Analysis.SpecialFunctions.Gaussian.FourierTransform

#check freePartitionFunction' M' N'

end FreeFlow
