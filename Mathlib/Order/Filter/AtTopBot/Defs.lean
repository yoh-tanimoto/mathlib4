/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
module

public import Mathlib.Data.Set.Piecewise
public import Mathlib.Order.Filter.Basic

/-!
# Definition of `Filter.atTop` and `Filter.atBot` filters

In this file we define the filters

* `Filter.atTop`: corresponds to `n ‚Üí +‚àû`;
* `Filter.atBot`: corresponds to `n ‚Üí -‚àû`.
-/

@[expose] public section

assert_not_exists Finset

variable {Œπ Œπ' Œ± Œ≤ Œ≥ : Type*}

open Set

namespace Filter

/-- `atTop` is the filter representing the limit `‚Üí ‚àû` on an ordered set.
It is generated by the collection of up-sets `{b | a ‚â§ b}`.
(The preorder need not have a top element for this to be well defined,
and indeed is trivial when a top element `x` exists, i.e., it coincides with `pure x`.) -/
@[to_dual
/-- `atBot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.
It is generated by the collection of down-sets `{b | b ‚â§ a}`.
(The preorder need not have a bottom element for this to be well defined,
and indeed is trivial when a bottom element `x` exists, i.e., it coincides with `pure x`.) -/]
def atTop [Preorder Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Ici a)

@[to_dual]
theorem mem_atTop [Preorder Œ±] (a : Œ±) : { b : Œ± | a ‚â§ b } ‚àà @atTop Œ± _ :=
  mem_iInf_of_mem a <| Subset.refl _

@[to_dual]
theorem Ici_mem_atTop [Preorder Œ±] (a : Œ±) : Ici a ‚àà (atTop : Filter Œ±) :=
  mem_atTop a

@[to_dual]
theorem Ioi_mem_atTop [Preorder Œ±] [NoTopOrder Œ±] (x : Œ±) : Ioi x ‚àà (atTop : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_not_le x
  mem_of_superset (inter_mem (mem_atTop x) (mem_atTop z))
    fun _ ‚ü®hxy, hzy‚ü© => lt_of_le_not_ge hxy fun hyx => hz (hzy.trans hyx)

@[to_dual eventually_le_atBot]
theorem eventually_ge_atTop [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a ‚â§ x :=
  mem_atTop a

@[to_dual eventually_lt_atBot]
theorem eventually_gt_atTop [Preorder Œ±] [NoTopOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a < x :=
  Ioi_mem_atTop a

@[to_dual]
theorem eventually_ne_atTop [Preorder Œ±] [NoTopOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, x ‚â† a :=
  (eventually_gt_atTop a).mono fun _ => ne_of_gt

@[to_dual]
theorem _root_.IsTop.atTop_eq [Preorder Œ±] {a : Œ±} (ha : IsTop a) : atTop = ùìü (Ici a) :=
  (iInf_le _ _).antisymm <| le_iInf fun b ‚Ü¶ principal_mono.2 <| Ici_subset_Ici.2 <| ha b

@[to_dual]
theorem atTop_eq_generate_Ici [Preorder Œ±] : atTop = generate (range (Ici (Œ± := Œ±))) := by
  simp only [generate_eq_biInf, atTop, iInf_range]

@[to_dual]
theorem Frequently.forall_exists_of_atTop [Preorder Œ±] {p : Œ± ‚Üí Prop}
    (h : ‚àÉ·∂† x in atTop, p x) (a : Œ±) : ‚àÉ b, a ‚â§ b ‚àß p b := by
  rw [Filter.Frequently] at h
  contrapose! h
  exact (eventually_ge_atTop a).mono h

@[to_dual]
lemma atTop_eq_generate_of_forall_exists_le [Preorder Œ±] {s : Set Œ±} (hs : ‚àÄ x, ‚àÉ y ‚àà s, x ‚â§ y) :
    (atTop : Filter Œ±) = generate (Ici '' s) := by
  rw [atTop_eq_generate_Ici]
  apply le_antisymm
  ¬∑ rw [le_generate_iff]
    rintro - ‚ü®y, -, rfl‚ü©
    exact mem_generate_of_mem ‚ü®y, rfl‚ü©
  ¬∑ rw [le_generate_iff]
    rintro - ‚ü®x, -, -, rfl‚ü©
    rcases hs x with ‚ü®y, ys, hy‚ü©
    have A : Ici y ‚àà generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)
    have B : Ici y ‚äÜ Ici x := Ici_subset_Ici.2 hy
    exact sets_of_superset (generate (Ici '' s)) A B

@[to_dual]
lemma atTop_eq_generate_of_not_bddAbove [LinearOrder Œ±] {s : Set Œ±} (hs : ¬¨ BddAbove s) :
    (atTop : Filter Œ±) = generate (Ici '' s) := by
  refine atTop_eq_generate_of_forall_exists_le fun x ‚Ü¶ ?_
  obtain ‚ü®y, hy, hy'‚ü© := not_bddAbove_iff.mp hs x
  exact ‚ü®y, hy, hy'.le‚ü©

end Filter

open Filter

theorem Monotone.piecewise_eventually_eq_iUnion {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}
    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÉ i, s i)]
    (hs : Monotone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :
    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÉ i, s i).piecewise f g a := by
  rcases em (‚àÉ i, a ‚àà s i) with ‚ü®i, hi‚ü© | ha
  ¬∑ refine (eventually_ge_atTop i).mono fun j hij ‚Ü¶ ?_
    simp only [Set.piecewise_eq_of_mem, hs hij hi, subset_iUnion _ _ hi]
  ¬∑ filter_upwards with i
    simp only [Set.piecewise_eq_of_notMem, not_exists.1 ha i, mt mem_iUnion.1 ha,
      not_false_eq_true]

theorem Antitone.piecewise_eventually_eq_iInter {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}
    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÇ i, s i)]
    (hs : Antitone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :
    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÇ i, s i).piecewise f g a := by
  classical
  convert ‚Üê (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3
  ¬∑ convert congr_fun (Set.piecewise_compl (s _) g f) a
  ¬∑ simp only [(¬∑ ‚àò ¬∑), ‚Üê compl_iInter, Set.piecewise_compl]
